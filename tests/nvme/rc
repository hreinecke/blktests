#!/bin/bash
# SPDX-License-Identifier: GPL-3.0+
# Copyright (C) 2018 Johannes Thumshirn
#
# Test specific to NVMe devices

. common/rc
. common/multipath-over-rdma
. common/nvmet

def_traddr="127.0.0.1"
def_adrfam="ipv4"
def_trsvcid="4420"
nvme_trtype=${nvme_trtype:-"loop"}

_nvme_requires() {
	_have_program nvme
	case ${nvme_trtype} in
	loop)
		_have_modules nvmet nvme-core nvme-loop
		_have_configfs
		;;
	pci)
		_have_modules nvme nvme-core
		;;
	tcp)
		_have_modules nvmet nvme-core nvme-tcp nvmet-tcp
		_have_configfs
		;;
	rdma)
		_have_modules nvmet nvme-core nvme-rdma nvmet-rdma
		_have_configfs
		_have_program rdma
		_have_modules rdma_rxe || _have_modules siw
		;;
	*)
		SKIP_REASON="unsupported nvme_trtype=${nvme_trtype}"
		return 1
	esac
	return 0
}

group_requires() {
	_have_root
}

group_device_requires() {
	_require_test_dev_is_nvme
}

NVMET_CFS="/sys/kernel/config/nvmet/"

_require_test_dev_is_nvme() {
	if ! readlink -f "$TEST_DEV_SYSFS/device" | grep -q nvme; then
		SKIP_REASON="$TEST_DEV is not a NVMe device"
		return 1
	fi
	return 0
}

_require_nvme_trtype_is_loop() {
	if [[ "${nvme_trtype}" != "loop" ]]; then
		SKIP_REASON="nvme_trtype=${nvme_trtype} is not supported in this test"
		return 1
	fi
	return 0
}

_require_nvme_trtype_is_fabrics() {
	if [[ "${nvme_trtype}" == "pci" ]]; then
		SKIP_REASON="nvme_trtype=${nvme_trtype} is not supported in this test"
		return 1
	fi
	return 0
}

_test_dev_nvme_ctrl() {
	echo "/dev/char/$(cat "${TEST_DEV_SYSFS}/device/dev")"
}

_test_dev_nvme_nsid() {
	cat "${TEST_DEV_SYSFS}/nsid"
}

_nvme_disconnect_ctrl() {
	local ctrl="$1"

	nvme disconnect -d "${ctrl}"
}

_nvme_disconnect_subsys() {
	local subsysnqn="$1"

	nvme disconnect -n "${subsysnqn}"
}

_nvme_connect_subsys() {
	local trtype="$1"
	local subsysnqn="$2"
	local traddr="${3:-$def_traddr}"
	local trsvcid="${4:-$def_trsvcid}"

	ARGS=(-t "${trtype}" -n "${subsysnqn}")
	if [[ "${trtype}" != "loop" ]]; then
		ARGS+=(-a "${traddr}" -s "${trsvcid}")
	fi
	nvme connect "${ARGS[@]}"
}

_nvme_discover() {
	local trtype="$1"
	local traddr="${2:-$def_traddr}"
	local trsvcid="${3:-$def_trsvcid}"

	ARGS=(-t "${trtype}")
	if [[ "${trtype}" != "loop" ]]; then
		ARGS+=(-a "${traddr}" -s "${trsvcid}")
	fi
	nvme discover "${ARGS[@]}"
}

_find_nvme_dev() {
	local subsys=$1
	local subsysnqn
	local dev
	for dev in /sys/class/nvme/nvme*; do
		dev="$(basename "$dev")"
		subsysnqn="$(cat "/sys/class/nvme/${dev}/subsysnqn")"
		if [[ "$subsysnqn" == "$subsys" ]]; then
			echo "$dev"
			for ((i = 0; i < 10; i++)); do
				if [[ -e /sys/block/$dev/uuid &&
					-e /sys/block/$dev/wwid ]]; then
					return
				fi
				sleep .1
			done
		fi
	done
}

_find_nvme_passthru_loop_dev() {
	local subsys=$1
	local nsid
	local dev

	dev=$(_find_nvme_dev "${subsys}")
	nsid=$(_test_dev_nvme_nsid)
	echo "/dev/${dev}n${nsid}"
}

_nvmet_passthru_target_connect() {
	local trtype=$1
	local subsys_name=$2

	_nvme_connect_subsys "${trtype}" "${subsys_name}"
	nsdev=$(_find_nvme_passthru_loop_dev "${subsys_name}")

	# The following tests can race with the creation
	# of the device so ensure the block device exists
	# before continuing
	while [ ! -b "${nsdev}" ]; do sleep 1; done

	echo "${nsdev}"
}

_filter_discovery() {
	sed -n -r -e "s/Generation counter [0-9]+/Generation counter X/" \
		  -e '/Discovery Log Number|Log Entry|trtype|subnqn/p'

}

_discovery_genctr() {
	_nvme_discover "${nvme_trtype}" |
		sed -n -e 's/^.*Generation counter \([0-9]\+\).*$/\1/p'
}
